module Vault_Template imports common, svm_core, transactions {

  type ImmutableState = Struct [
    owner: Address,
    totalAmount: CoinAmount,
    initialUnlockAmount: CoinAmount,
    vestingStart: LayerHeight,
    vestingEnd: LayerHeight
  ]

  type MutableState = Struct [
    drainedSoFar: CoinAmount
  ]

  behaviour Mount(vm: TemplateMountSocket) implements TemplateMountAPI[ImmutableState,MutableState] {

    fun parsePayload(tx: Transaction): ParsedPayload throws ParsingError {
      switch typeOf(tx) {
        case SelfSpawnTx: throw Error("Not supported for this template")
        case SpawnTx: throw Error("Not supported for this template")
        case LocalMethodCall: throw Error("Not supported for this template")
        case ForeignMethodCallTx: throw Error("Not supported for this template")
        case TemplateDeployTx: throw Error("Not supported in this version of SVM")
      }
    }

    @autogenerated
    fun maxSpend(methodSelector: Int, accountImmutableState: IS, parsedPayload: ParsedPayload): CoinAmount

    fun verifyTx(accountImmutableState: IS, txSerialized: Wrapper, tx: Transaction, parsedPayload: ParsedPayload): Boolean {
      //always returning false because Vault is "pure smart contract" account, i.e. it cannot be used as a principal
      return false
    }

    fun parseImmutableState(wrapper: Wrapper): ImmutableState {
      return Quipu.parse[ImmutableState](wrapper)
    }

    @autogenerated
    fun parseCallArgs[T](methodSelector: u16, wrapper: Wrapper): T

    @autogenerated
    fun instanceMethods(): Seq[u16]

    @autogenerated
    fun methodSignature(methodId: u16): InstanceMethodSignature

    fun accountCreationHandler(accountAddress: Address, immutableState: ImmutableState, creator: Account): MutableState {
      //no special processing here
      return MutableState()
    }

    fun authorizeCall(enclosingTransaction: Transaction, caller: Address, method: u16, args: T): Boolean {
      return caller == owner
    }

  }

  interface InstanceMethods {

    @methodSelector=16
    @maxSpend=0
    fun spend(recipient: Address, amount: CoinsAmount): CoinAmount

  }

  behaviour AccountImpl(hostAPI: HostAPI, owner: Address, totalAmount: CoinAmount, initialUnlockAmount: CoinAmount, vestingStart: LayerHeight, vestingEnd: LayerHeight) implements InstanceMethods {
    var drainedSoFar: CoinAmount = 0

    @private
    fun availableToUnlock(): CoinAmount = {
      if (hostAPI.layerId() < vestingStart
        return 0

      if (hostAPI.layerId() >= vestingEnd)
        return totalAmount

      val vestingPeriodLength: u32 = vestingEnd - vestingStart
      val relativeBlockchainTime: u32 = hostAPI.layerId() - vestingStart
      val tailAmount: CoinAmount = totalAmount - initialUnlockAmount
      //because we do integer division below and all numbers are non-negative, this rounds towards zero
      val incrementalUnlock: CoinsAmount = tail * relativeBlockchainTime / vestingPeriodLength
      return initialUnlockAmount + incrementalUnlock
    }

    fun spend(recipient: Address, amount: CoinAmount): CoinAmount = {
      if amount > (availableToUnlock() - drainedSoFar)
        throw Error("requested amount exceeds currently available unlocked balance")

      drainedSoFar = drainedSoFar + amount
      hostApi.transfer(recipient, amount)
    }
  }

}